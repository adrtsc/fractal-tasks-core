{
  "args_schema_version": "pydantic_v1",
  "has_args_schemas": true,
  "manifest_version": "2",
  "task_list": [
    {
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "definitions": {
          "OmeroChannel": {
            "description": "Custom class for Omero channels, based on OME-NGFF v0.4.",
            "properties": {
              "active": {
                "default": true,
                "description": "Should this channel be shown in the viewer?",
                "title": "Active",
                "type": "boolean"
              },
              "coefficient": {
                "default": 1,
                "description": "Do not change. Omero-channel attribute.",
                "title": "Coefficient",
                "type": "integer"
              },
              "color": {
                "description": "Optional hex colormap to display the channel in napari (it must be of length 6, e.g. `00FFFF`).",
                "title": "Color",
                "type": "string"
              },
              "index": {
                "description": "Do not change. For internal use only.",
                "title": "Index",
                "type": "integer"
              },
              "inverted": {
                "default": false,
                "description": "Do not change. Omero-channel attribute.",
                "title": "Inverted",
                "type": "boolean"
              },
              "label": {
                "description": "Name of the channel.",
                "title": "Label",
                "type": "string"
              },
              "wavelength_id": {
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`.",
                "title": "Wavelength Id",
                "type": "string"
              },
              "window": {
                "$ref": "#/definitions/Window",
                "description": "Optional `Window` object to set default display settings for napari.",
                "title": "Window"
              }
            },
            "required": [
              "wavelength_id"
            ],
            "title": "OmeroChannel",
            "type": "object"
          },
          "Window": {
            "description": "Custom class for Omero-channel window, based on OME-NGFF v0.4.",
            "properties": {
              "end": {
                "description": "Upper-bound rescaling value for visualization.",
                "title": "End",
                "type": "integer"
              },
              "max": {
                "description": "Do not change. It will be set according to bit-depth of the images by default (e.g. 65535 for 16 bit images).",
                "title": "Max",
                "type": "integer"
              },
              "min": {
                "description": "Do not change. It will be set to `0` by default.",
                "title": "Min",
                "type": "integer"
              },
              "start": {
                "description": "Lower-bound rescaling value for visualization.",
                "title": "Start",
                "type": "integer"
              }
            },
            "required": [
              "start",
              "end"
            ],
            "title": "Window",
            "type": "object"
          }
        },
        "properties": {
          "allowed_channels": {
            "description": "A list of `OmeroChannel` s, where each channel must include the `wavelength_id` attribute and where the `wavelength_id` values must be unique across the list.",
            "items": {
              "$ref": "#/definitions/OmeroChannel"
            },
            "title": "Allowed Channels",
            "type": "array"
          },
          "coarsening_xy": {
            "default": 2,
            "description": "Linear coarsening factor between subsequent levels. If set to `2`, level 1 is 2x downsampled, level 2 is 4x downsampled etc.",
            "title": "Coarsening Xy",
            "type": "integer"
          },
          "image_dirs": {
            "description": "list of paths to the folders that contains the Cellvoyager image files. Each entry is a path to a folder that contains the image files themselves for a multiwell plate and the MeasurementData & MeasurementDetail metadata files.",
            "items": {
              "type": "string"
            },
            "title": "Image Dirs",
            "type": "array"
          },
          "image_extension": {
            "default": "tif",
            "description": "Filename extension of images (e.g. `\"tif\"` or `\"png\"`)",
            "title": "Image Extension",
            "type": "string"
          },
          "image_glob_patterns": {
            "description": "If specified, only parse images with filenames that match with all these patterns. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html, Example: `image_glob_pattern=[\"*_B03_*\"]` => only process well B03 `image_glob_pattern=[\"*_C09_*\", \"*F016*\", \"*Z[0-5][0-9]C*\"]` => only process well C09, field of view 16 and Z planes 0-59.",
            "items": {
              "type": "string"
            },
            "title": "Image Glob Patterns",
            "type": "array"
          },
          "metadata_table_file": {
            "description": "If `None`, parse Yokogawa metadata from mrf/mlf files in the input_path folder; else, the full path to a csv file containing the parsed metadata table.",
            "title": "Metadata Table File",
            "type": "string"
          },
          "num_levels": {
            "default": 5,
            "description": "Number of resolution-pyramid levels. If set to `5`, there will be the full-resolution level and 4 levels of downsampled images.",
            "title": "Num Levels",
            "type": "integer"
          },
          "overwrite": {
            "default": false,
            "description": "If `True`, overwrite the task output.",
            "title": "Overwrite",
            "type": "boolean"
          },
          "zarr_dir": {
            "description": "path of the directory where the new OME-Zarrs will be created. (standard argument for Fractal tasks, managed by Fractal server).",
            "title": "Zarr Dir",
            "type": "string"
          },
          "zarr_urls": {
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. Not used by the converter task. (standard argument for Fractal tasks, managed by Fractal server).",
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array"
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir",
          "image_dirs",
          "allowed_channels"
        ],
        "title": "CellvoyagerToOmeZarrInit",
        "type": "object"
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "definitions": {
          "InitArgsCellVoyager": {
            "description": "Arguments to be passed from cellvoyager converter init to compute",
            "properties": {
              "acquisition": {
                "title": "Acquisition",
                "type": "integer"
              },
              "image_dir": {
                "title": "Image Dir",
                "type": "string"
              },
              "image_extension": {
                "title": "Image Extension",
                "type": "string"
              },
              "image_glob_patterns": {
                "items": {
                  "type": "string"
                },
                "title": "Image Glob Patterns",
                "type": "array"
              },
              "plate_prefix": {
                "title": "Plate Prefix",
                "type": "string"
              },
              "well_ID": {
                "title": "Well Id",
                "type": "string"
              }
            },
            "required": [
              "image_dir",
              "plate_prefix",
              "well_ID",
              "image_extension"
            ],
            "title": "InitArgsCellVoyager",
            "type": "object"
          }
        },
        "properties": {
          "init_args": {
            "$ref": "#/definitions/InitArgsCellVoyager",
            "description": "Intialization arguments provided by `create_cellvoyager_ome_zarr_init`.",
            "title": "Init_Args"
          },
          "overwrite": {
            "default": false,
            "description": "If `True`, overwrite the task output.",
            "title": "Overwrite",
            "type": "boolean"
          },
          "zarr_url": {
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).",
            "title": "Zarr Url",
            "type": "string"
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "title": "CellvoyagerToOmeZarrCompute",
        "type": "object"
      },
      "docs_info": "## cellvoyager_to_ome_zarr_init\nCreate a OME-NGFF zarr folder, without reading/writing image data.\n\nFind plates (for each folder in input_paths):\n\n- glob image files,\n- parse metadata from image filename to identify plates,\n- identify populated channels.\n\nCreate a zarr folder (for each plate):\n\n- parse mlf metadata,\n- identify wells and field of view (FOV),\n- create FOV ZARR,\n- verify that channels are uniform (i.e., same channels).\n## cellvoyager_to_ome_zarr_compute\nConvert Yokogawa output (png, tif) to zarr file.\n\nThis task is typically run after Create OME-Zarr or\nCreate OME-Zarr Multiplexing and populates the empty OME-Zarr files that\nwere prepared.\n",
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core",
      "executable_non_parallel": "tasks/cellvoyager_to_ome_zarr_init.py",
      "executable_parallel": "tasks/cellvoyager_to_ome_zarr_compute.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "name": "Convert Cellvoyager to OME-Zarr"
    },
    {
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "definitions": {
          "MultiplexingAcquisition": {
            "description": "Input class for Multiplexing Cellvoyager converter",
            "properties": {
              "allowed_channels": {
                "items": {
                  "$ref": "#/definitions/OmeroChannel"
                },
                "title": "Allowed Channels",
                "type": "array"
              },
              "image_dir": {
                "title": "Image Dir",
                "type": "string"
              }
            },
            "required": [
              "image_dir",
              "allowed_channels"
            ],
            "title": "MultiplexingAcquisition",
            "type": "object"
          },
          "OmeroChannel": {
            "description": "Custom class for Omero channels, based on OME-NGFF v0.4.",
            "properties": {
              "active": {
                "default": true,
                "description": "Should this channel be shown in the viewer?",
                "title": "Active",
                "type": "boolean"
              },
              "coefficient": {
                "default": 1,
                "description": "Do not change. Omero-channel attribute.",
                "title": "Coefficient",
                "type": "integer"
              },
              "color": {
                "description": "Optional hex colormap to display the channel in napari (it must be of length 6, e.g. `00FFFF`).",
                "title": "Color",
                "type": "string"
              },
              "index": {
                "description": "Do not change. For internal use only.",
                "title": "Index",
                "type": "integer"
              },
              "inverted": {
                "default": false,
                "description": "Do not change. Omero-channel attribute.",
                "title": "Inverted",
                "type": "boolean"
              },
              "label": {
                "description": "Name of the channel.",
                "title": "Label",
                "type": "string"
              },
              "wavelength_id": {
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`.",
                "title": "Wavelength Id",
                "type": "string"
              },
              "window": {
                "$ref": "#/definitions/Window",
                "description": "Optional `Window` object to set default display settings for napari.",
                "title": "Window"
              }
            },
            "required": [
              "wavelength_id"
            ],
            "title": "OmeroChannel",
            "type": "object"
          },
          "Window": {
            "description": "Custom class for Omero-channel window, based on OME-NGFF v0.4.",
            "properties": {
              "end": {
                "description": "Upper-bound rescaling value for visualization.",
                "title": "End",
                "type": "integer"
              },
              "max": {
                "description": "Do not change. It will be set according to bit-depth of the images by default (e.g. 65535 for 16 bit images).",
                "title": "Max",
                "type": "integer"
              },
              "min": {
                "description": "Do not change. It will be set to `0` by default.",
                "title": "Min",
                "type": "integer"
              },
              "start": {
                "description": "Lower-bound rescaling value for visualization.",
                "title": "Start",
                "type": "integer"
              }
            },
            "required": [
              "start",
              "end"
            ],
            "title": "Window",
            "type": "object"
          }
        },
        "properties": {
          "acquisitions": {
            "additionalProperties": {
              "$ref": "#/definitions/MultiplexingAcquisition"
            },
            "description": "dictionary of acquisitions. Each key is the acquisition identifier (normally 0, 1, 2, 3 etc.). Each item defines the acquisition by providing the image_dir and the allowed_channels.",
            "title": "Acquisitions",
            "type": "object"
          },
          "coarsening_xy": {
            "default": 2,
            "description": "Linear coarsening factor between subsequent levels. If set to `2`, level 1 is 2x downsampled, level 2 is 4x downsampled etc.",
            "title": "Coarsening Xy",
            "type": "integer"
          },
          "image_extension": {
            "default": "tif",
            "description": "Filename extension of images (e.g. `\"tif\"` or `\"png\"`).",
            "title": "Image Extension",
            "type": "string"
          },
          "image_glob_patterns": {
            "description": "If specified, only parse images with filenames that match with all these patterns. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html, Example: `image_glob_pattern=[\"*_B03_*\"]` => only process well B03 `image_glob_pattern=[\"*_C09_*\", \"*F016*\", \"*Z[0-5][0-9]C*\"]` => only process well C09, field of view 16 and Z planes 0-59.",
            "items": {
              "type": "string"
            },
            "title": "Image Glob Patterns",
            "type": "array"
          },
          "metadata_table_files": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "If `None`, parse Yokogawa metadata from mrf/mlf files in the input_path folder; else, a dictionary of key-value pairs like `(acquisition, path)` with `acquisition` a string like the key of the `acquisitions` dict and `path` pointing to a csv file containing the parsed metadata table.",
            "title": "Metadata Table Files",
            "type": "object"
          },
          "num_levels": {
            "default": 5,
            "description": "Number of resolution-pyramid levels. If set to `5`, there will be the full-resolution level and 4 levels of downsampled images.",
            "title": "Num Levels",
            "type": "integer"
          },
          "overwrite": {
            "default": false,
            "description": "If `True`, overwrite the task output.",
            "title": "Overwrite",
            "type": "boolean"
          },
          "zarr_dir": {
            "description": "path of the directory where the new OME-Zarrs will be created. (standard argument for Fractal tasks, managed by Fractal server).",
            "title": "Zarr Dir",
            "type": "string"
          },
          "zarr_urls": {
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. Not used by the converter task. (standard argument for Fractal tasks, managed by Fractal server).",
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array"
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir",
          "acquisitions"
        ],
        "title": "CellvoyagerToOmeZarrInitMultiplex",
        "type": "object"
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "definitions": {
          "InitArgsCellVoyager": {
            "description": "Arguments to be passed from cellvoyager converter init to compute",
            "properties": {
              "acquisition": {
                "title": "Acquisition",
                "type": "integer"
              },
              "image_dir": {
                "title": "Image Dir",
                "type": "string"
              },
              "image_extension": {
                "title": "Image Extension",
                "type": "string"
              },
              "image_glob_patterns": {
                "items": {
                  "type": "string"
                },
                "title": "Image Glob Patterns",
                "type": "array"
              },
              "plate_prefix": {
                "title": "Plate Prefix",
                "type": "string"
              },
              "well_ID": {
                "title": "Well Id",
                "type": "string"
              }
            },
            "required": [
              "image_dir",
              "plate_prefix",
              "well_ID",
              "image_extension"
            ],
            "title": "InitArgsCellVoyager",
            "type": "object"
          }
        },
        "properties": {
          "init_args": {
            "$ref": "#/definitions/InitArgsCellVoyager",
            "description": "Intialization arguments provided by `create_cellvoyager_ome_zarr_init`.",
            "title": "Init_Args"
          },
          "overwrite": {
            "default": false,
            "description": "If `True`, overwrite the task output.",
            "title": "Overwrite",
            "type": "boolean"
          },
          "zarr_url": {
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).",
            "title": "Zarr Url",
            "type": "string"
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "title": "CellvoyagerToOmeZarrCompute",
        "type": "object"
      },
      "docs_info": "## cellvoyager_to_ome_zarr_init_multiplex\nCreate OME-NGFF structure and metadata to host a multiplexing dataset.\n\nThis task takes a set of image folders (i.e. different acquisition cycles)\nand build the internal structure and metadata of a OME-NGFF zarr group,\nwithout actually loading/writing the image data.\n\nEach element in input_paths should be treated as a different acquisition.\n## cellvoyager_to_ome_zarr_compute\nConvert Yokogawa output (png, tif) to zarr file.\n\nThis task is typically run after Create OME-Zarr or\nCreate OME-Zarr Multiplexing and populates the empty OME-Zarr files that\nwere prepared.\n",
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core",
      "executable_non_parallel": "tasks/cellvoyager_to_ome_zarr_init_multiplex.py",
      "executable_parallel": "tasks/cellvoyager_to_ome_zarr_compute.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "name": "Convert Cellvoyager Multiplexing to OME-Zarr"
    },
    {
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "overwrite": {
            "default": false,
            "description": "If `True`, overwrite the task output.",
            "title": "Overwrite",
            "type": "boolean"
          },
          "suffix": {
            "default": "mip",
            "description": "The suffix that is used to transform `plate.zarr` into `plate_suffix.zarr`. Note that `None` is not currently supported.",
            "title": "Suffix",
            "type": "string"
          },
          "zarr_dir": {
            "description": "path of the directory where the new OME-Zarrs will be created. (standard argument for Fractal tasks, managed by Fractal server).",
            "title": "Zarr Dir",
            "type": "string"
          },
          "zarr_urls": {
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).",
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array"
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "title": "CopyOmeZarrHcsPlate",
        "type": "object"
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "definitions": {
          "InitArgsMIP": {
            "description": "Init Args for MIP task.",
            "properties": {
              "origin_url": {
                "title": "Origin Url",
                "type": "string"
              }
            },
            "required": [
              "origin_url"
            ],
            "title": "InitArgsMIP",
            "type": "object"
          }
        },
        "properties": {
          "init_args": {
            "$ref": "#/definitions/InitArgsMIP",
            "description": "Intialization arguments provided by `create_cellvoyager_ome_zarr_init`.",
            "title": "Init_Args"
          },
          "overwrite": {
            "default": false,
            "description": "If `True`, overwrite the task output.",
            "title": "Overwrite",
            "type": "boolean"
          },
          "zarr_url": {
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).",
            "title": "Zarr Url",
            "type": "string"
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "title": "MaximumIntensityProjection",
        "type": "object"
      },
      "docs_info": "## copy_ome_zarr_hcs_plate\nDuplicate the OME-Zarr HCS structure for a set of zarr_urls.\n\nThis task only processes the zarr images in the zarr_urls, not all the\nimages in the plate. It copies all the  plate & well structure, but none\nof the image metadata or the actual image data:\n\n- For each plate, create a new OME-Zarr HCS plate with the attributes for\n    all the images in zarr_urls\n- For each well (in each plate), create a new zarr subgroup with the\n   same attributes as the original one.\n\nNote: this task makes use of methods from the `Attributes` class, see\nhttps://zarr.readthedocs.io/en/stable/api/attrs.html.\n## maximum_intensity_projection\nPerform maximum-intensity projection along Z axis.\n\nNote: this task stores the output in a new zarr file.\n",
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core",
      "executable_non_parallel": "tasks/copy_ome_zarr_hcs_plate.py",
      "executable_parallel": "tasks/maximum_intensity_projection.py",
      "input_types": {
        "is_3D": true
      },
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "name": "Maximum Intensity Projection HCS Plate",
      "output_types": {
        "is_3D": false
      }
    },
    {
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "background": {
            "default": 110,
            "description": "Background value that is subtracted from the image before the illumination correction is applied. Set it to `0` if you don't want any background subtraction.",
            "title": "Background",
            "type": "integer"
          },
          "dict_corr": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Dictionary where keys match the `wavelength_id` attributes of existing channels (e.g. `A01_C01` ) and values are the filenames of the corresponding illumination profiles.",
            "title": "Dict Corr",
            "type": "object"
          },
          "illumination_profiles_folder": {
            "description": "Path of folder of illumination profiles.",
            "title": "Illumination Profiles Folder",
            "type": "string"
          },
          "input_ROI_table": {
            "default": "FOV_ROI_table",
            "description": "Name of the ROI table that contains the information about the location of the individual field of views (FOVs) to which the illumination correction shall be applied. Defaults to \"FOV_ROI_table\", the default name Fractal converters give the ROI tables that list all FOVs separately. If you generated your OME-Zarr with a different converter and used Import OME-Zarr to generate the ROI tables, `image_ROI_table` is the right choice if you only have 1 FOV per Zarr image and `grid_ROI_table` if you have multiple FOVs per Zarr image and set the right grid options during import.",
            "title": "Input Roi Table",
            "type": "string"
          },
          "overwrite_input": {
            "default": true,
            "description": "If `True`, the results of this task will overwrite the input image data. If false, a new image is generated and the illumination corrected data is saved there.",
            "title": "Overwrite Input",
            "type": "boolean"
          },
          "suffix": {
            "default": "_illum_corr",
            "description": "What suffix to append to the illumination corrected images. Only relevant if overwrite_input=False.",
            "title": "Suffix",
            "type": "string"
          },
          "zarr_url": {
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).",
            "title": "Zarr Url",
            "type": "string"
          }
        },
        "required": [
          "zarr_url",
          "illumination_profiles_folder",
          "dict_corr"
        ],
        "title": "IlluminationCorrection",
        "type": "object"
      },
      "docs_info": "## illumination_correction\nApplies illumination correction to the images in the OME-Zarr.\n\nAssumes that the illumination correction profiles were generated before\nseparately and that the same background subtraction was used during\ncalculation of the illumination correction (otherwise, it will not work\nwell & the correction may only be partial).\n",
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core",
      "executable_parallel": "tasks/illumination_correction.py",
      "input_types": {
        "illumination_corrected": false
      },
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "name": "Illumination Correction",
      "output_types": {
        "illumination_corrected": true
      }
    },
    {
      "args_schema_parallel": {
        "additionalProperties": false,
        "definitions": {
          "CellposeCustomNormalizer": {
            "description": "Validator to handle different normalization scenarios for Cellpose models",
            "properties": {
              "lower_bound": {
                "description": "Explicit lower bound value to rescale the image at. Needs to be an integer, e.g. 100. You can only specify percentiles or bounds, not both.",
                "title": "Lower Bound",
                "type": "integer"
              },
              "lower_percentile": {
                "description": "Specify a custom lower-bound percentile for rescaling as a float value between 0 and 100. Set to 1 to run the same as default). You can only specify percentiles or bounds, not both.",
                "maximum": 100,
                "minimum": 0,
                "title": "Lower Percentile",
                "type": "number"
              },
              "type": {
                "default": "default",
                "description": "One of `default` (Cellpose default normalization), `custom` (using the other custom parameters) or `no_normalization`.",
                "enum": [
                  "default",
                  "custom",
                  "no_normalization"
                ],
                "title": "Type",
                "type": "string"
              },
              "upper_bound": {
                "description": "Explicit upper bound value to rescale the image at. Needs to be an integer, e.g. 2000. You can only specify percentiles or bounds, not both.",
                "title": "Upper Bound",
                "type": "integer"
              },
              "upper_percentile": {
                "description": "Specify a custom upper-bound percentile for rescaling as a float value between 0 and 100. Set to 99 to run the same as default, set to e.g. 99.99 if the default rescaling was too harsh. You can only specify percentiles or bounds, not both.",
                "maximum": 100,
                "minimum": 0,
                "title": "Upper Percentile",
                "type": "number"
              }
            },
            "title": "CellposeCustomNormalizer",
            "type": "object"
          },
          "ChannelInputModel": {
            "description": "A channel which is specified by either `wavelength_id` or `label`.",
            "properties": {
              "label": {
                "description": "Name of the channel.",
                "title": "Label",
                "type": "string"
              },
              "wavelength_id": {
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`.",
                "title": "Wavelength Id",
                "type": "string"
              }
            },
            "title": "ChannelInputModel",
            "type": "object"
          }
        },
        "properties": {
          "anisotropy": {
            "description": "Ratio of the pixel sizes along Z and XY axis (ignored if the image is not three-dimensional). If `None`, it is inferred from the OME-NGFF metadata.",
            "title": "Anisotropy",
            "type": "number"
          },
          "augment": {
            "default": false,
            "description": "Parameter of `CellposeModel` class. Whether to use cellpose augmentation to tile images with overlap.",
            "title": "Augment",
            "type": "boolean"
          },
          "batch_size": {
            "default": 8,
            "description": "number of 224x224 patches to run simultaneously on the GPU (can make smaller or bigger depending on GPU memory usage)",
            "title": "Batch Size",
            "type": "integer"
          },
          "cellprob_threshold": {
            "default": 0.0,
            "description": "Parameter of `CellposeModel.eval` method. Valid values between -6 to 6. From Cellpose documentation: \"Decrease this threshold if cellpose is not returning as many ROIs as you\u2019d expect. Similarly, increase this threshold if cellpose is returning too ROIs particularly from dim areas.\"",
            "title": "Cellprob Threshold",
            "type": "number"
          },
          "channel": {
            "$ref": "#/definitions/ChannelInputModel",
            "description": "Primary channel for segmentation; requires either `wavelength_id` (e.g. `A01_C01`) or `label` (e.g. `DAPI`).",
            "title": "Channel"
          },
          "channel2": {
            "$ref": "#/definitions/ChannelInputModel",
            "description": "Second channel for segmentation (in the same format as `channel`). If specified, cellpose runs in dual channel mode. For dual channel segmentation of cells, the first channel should contain the membrane marker, the second channel should contain the nuclear marker.",
            "title": "Channel2"
          },
          "diameter_level0": {
            "default": 30.0,
            "description": "Expected diameter of the objects that should be segmented in pixels at level 0. Initial diameter is rescaled using the `level` that was selected. The rescaled value is passed as the diameter to the `CellposeModel.eval` method.",
            "title": "Diameter Level0",
            "type": "number"
          },
          "flow_threshold": {
            "default": 0.4,
            "description": "Parameter of `CellposeModel.eval` method. Valid values between 0.0 and 1.0. From Cellpose documentation: \"Increase this threshold if cellpose is not returning as many ROIs as you\u2019d expect. Similarly, decrease this threshold if cellpose is returning too many ill-shaped ROIs.\"",
            "title": "Flow Threshold",
            "type": "number"
          },
          "input_ROI_table": {
            "default": "FOV_ROI_table",
            "description": "Name of the ROI table over which the task loops to apply Cellpose segmentation. Examples: `FOV_ROI_table` => loop over the field of views, `organoid_ROI_table` => loop over the organoid ROI table (generated by another task), `well_ROI_table` => process the whole well as one image.",
            "title": "Input Roi Table",
            "type": "string"
          },
          "interp": {
            "default": true,
            "description": "interpolate during 2D dynamics (not available in 3D) (in previous versions it was False, now it defaults to True)",
            "title": "Interp",
            "type": "boolean"
          },
          "invert": {
            "default": false,
            "description": "invert image pixel intensity before running network (if True, image is also normalized)",
            "title": "Invert",
            "type": "boolean"
          },
          "level": {
            "description": "Pyramid level of the image to be segmented. Choose `0` to process at full resolution.",
            "title": "Level",
            "type": "integer"
          },
          "min_size": {
            "default": 15,
            "description": "Parameter of `CellposeModel` class. Minimum size of the segmented objects (in pixels). Use `-1` to turn off the size filter.",
            "title": "Min Size",
            "type": "integer"
          },
          "model_type": {
            "default": "cyto2",
            "description": "Parameter of `CellposeModel` class. Defines which model should be used. Typical choices are `nuclei`, `cyto`, `cyto2`, etc.",
            "enum": [
              "cyto",
              "nuclei",
              "tissuenet",
              "livecell",
              "cyto2",
              "general",
              "CP",
              "CPx",
              "TN1",
              "TN2",
              "TN3",
              "LC1",
              "LC2",
              "LC3",
              "LC4"
            ],
            "title": "Model Type",
            "type": "string"
          },
          "net_avg": {
            "default": false,
            "description": "Parameter of `CellposeModel` class. Whether to use cellpose net averaging to run the 4 built-in networks (useful for `nuclei`, `cyto` and `cyto2`, not sure it works for the others).",
            "title": "Net Avg",
            "type": "boolean"
          },
          "normalize": {
            "allOf": [
              {
                "$ref": "#/definitions/CellposeCustomNormalizer"
              }
            ],
            "default": {
              "lower_bound": null,
              "lower_percentile": null,
              "type": "default",
              "upper_bound": null,
              "upper_percentile": null
            },
            "description": "By default, data is normalized so 0.0=1st percentile and 1.0=99th percentile of image intensities in each channel. This automatic normalization can lead to issues when the image to be segmented is very sparse. You can turn off the default rescaling. With the \"custom\" option, you can either provide your own rescaling percentiles or fixed rescaling upper and lower bound integers.",
            "title": "Normalize"
          },
          "output_ROI_table": {
            "description": "If provided, a ROI table with that name is created, which will contain the bounding boxes of the newly segmented labels. ROI tables should have `ROI` in their name.",
            "title": "Output Roi Table",
            "type": "string"
          },
          "output_label_name": {
            "description": "Name of the output label image (e.g. `\"organoids\"`).",
            "title": "Output Label Name",
            "type": "string"
          },
          "overwrite": {
            "default": true,
            "description": "If `True`, overwrite the task output.",
            "title": "Overwrite",
            "type": "boolean"
          },
          "pretrained_model": {
            "description": "Parameter of `CellposeModel` class (takes precedence over `model_type`). Allows you to specify the path of a custom trained cellpose model.",
            "title": "Pretrained Model",
            "type": "string"
          },
          "relabeling": {
            "default": true,
            "description": "If `True`, apply relabeling so that label values are unique for all objects in the well.",
            "title": "Relabeling",
            "type": "boolean"
          },
          "resample": {
            "default": true,
            "description": "run dynamics at original image size (will be slower but create more accurate boundaries)",
            "title": "Resample",
            "type": "boolean"
          },
          "stitch_threshold": {
            "default": 0.0,
            "description": "if stitch_threshold>0.0 and not do_3D and equal image sizes, masks are stitched in 3D to return volume segmentation",
            "title": "Stitch Threshold",
            "type": "number"
          },
          "tile": {
            "default": true,
            "description": "tiles image to ensure GPU/CPU memory usage limited (recommended)",
            "title": "Tile",
            "type": "boolean"
          },
          "tile_overlap": {
            "default": 0.1,
            "description": "fraction of overlap of tiles when computing flows",
            "title": "Tile Overlap",
            "type": "number"
          },
          "use_gpu": {
            "default": true,
            "description": "If `False`, always use the CPU; if `True`, use the GPU if possible (as defined in `cellpose.core.use_gpu()`) and fall-back to the CPU otherwise.",
            "title": "Use Gpu",
            "type": "boolean"
          },
          "use_masks": {
            "default": true,
            "description": "If `True`, try to use masked loading and fall back to `use_masks=False` if the ROI table is not suitable. Masked loading is relevant when only a subset of the bounding box should actually be processed (e.g. running within `organoid_ROI_table`).",
            "title": "Use Masks",
            "type": "boolean"
          },
          "zarr_url": {
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).",
            "title": "Zarr Url",
            "type": "string"
          }
        },
        "required": [
          "zarr_url",
          "level",
          "channel"
        ],
        "title": "CellposeSegmentation",
        "type": "object"
      },
      "docs_info": "## cellpose_segmentation\nRun cellpose segmentation on the ROIs of a single OME-Zarr image.\n",
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core",
      "executable_parallel": "tasks/cellpose_segmentation.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000,
        "needs_gpu": true
      },
      "name": "Cellpose Segmentation"
    },
    {
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "reference_cycle": {
            "default": 0,
            "description": "Which cycle to register against. Needs to match the acquisition metadata in the OME-Zarr image.",
            "title": "Reference Cycle",
            "type": "integer"
          },
          "zarr_dir": {
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server).",
            "title": "Zarr Dir",
            "type": "string"
          },
          "zarr_urls": {
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).",
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array"
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "title": "ImageBasedRegistrationHcsInit",
        "type": "object"
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "definitions": {
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          }
        },
        "properties": {
          "init_args": {
            "$ref": "#/definitions/InitArgsRegistration",
            "description": "Intialization arguments provided by `image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server).",
            "title": "Init_Args"
          },
          "level": {
            "default": 2,
            "description": "Pyramid level of the image to be used for registration. Choose `0` to process at full resolution.",
            "title": "Level",
            "type": "integer"
          },
          "roi_table": {
            "default": "FOV_ROI_table",
            "description": "Name of the ROI table over which the task loops to calculate the registration. Examples: `FOV_ROI_table` => loop over the field of views, `well_ROI_table` => process the whole well as one image.",
            "title": "Roi Table",
            "type": "string"
          },
          "wavelength_id": {
            "description": "Wavelength that will be used for image-based registration; e.g. `A01_C01` for Yokogawa, `C01` for MD.",
            "title": "Wavelength Id",
            "type": "string"
          },
          "zarr_url": {
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).",
            "title": "Zarr Url",
            "type": "string"
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "wavelength_id"
        ],
        "title": "CalculateRegistrationImageBased",
        "type": "object"
      },
      "docs_info": "## image_based_registration_hcs_init\nInitialized calculate registration task\n\nThis task prepares a parallelization list of all zarr_urls that need to be\nused to calculate the registration between cycles (all zarr_urls except\nthe reference cycle vs. the reference cycle).\nThis task only works for HCS OME-Zarrs for 2 reasons: Only HCS OME-Zarrs\ncurrently have defined acquisition metadata to determine reference cycles.\nAnd we have only implemented the grouping of images for HCS OME-Zarrs by\nwell (with the assumption that every well just has 1 image per acqusition).\n## calculate_registration_image_based\nCalculate registration based on images\n\nThis task consists of 3 parts:\n\n1. Loading the images of a given ROI (=> loop over ROIs)\n2. Calculating the transformation for that ROI\n3. Storing the calculated transformation in the ROI table\n",
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core",
      "executable_non_parallel": "tasks/image_based_registration_hcs_init.py",
      "executable_parallel": "tasks/calculate_registration_image_based.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 8000
      },
      "name": "Calculate Registration (image-based)"
    },
    {
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "reference_cycle": {
            "default": 0,
            "description": "Which cycle to register against. Defaults to 0, which is the first OME-Zarr image in the well, usually the first cycle that was provided",
            "title": "Reference Cycle",
            "type": "integer"
          },
          "zarr_dir": {
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server).",
            "title": "Zarr Dir",
            "type": "string"
          },
          "zarr_urls": {
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).",
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array"
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "title": "InitGroupByWellForMultiplexing",
        "type": "object"
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "definitions": {
          "InitArgsRegistrationConsensus": {
            "description": "Registration consensus init args.",
            "properties": {
              "zarr_url_list": {
                "items": {
                  "type": "string"
                },
                "title": "Zarr Url List",
                "type": "array"
              }
            },
            "required": [
              "zarr_url_list"
            ],
            "title": "InitArgsRegistrationConsensus",
            "type": "object"
          }
        },
        "properties": {
          "init_args": {
            "$ref": "#/definitions/InitArgsRegistrationConsensus",
            "description": "Intialization arguments provided by `init_group_by_well_for_multiplexing`. It contains the zarr_url_list listing all the zarr_urls in the same well as the zarr_url of the reference cycle that are being processed. (standard argument for Fractal tasks, managed by Fractal server).",
            "title": "Init_Args"
          },
          "new_roi_table": {
            "description": "Optional name for the new, registered ROI table. If no name is given, it will default to \"registered_\" + `roi_table`",
            "title": "New Roi Table",
            "type": "string"
          },
          "roi_table": {
            "default": "FOV_ROI_table",
            "description": "Name of the ROI table over which the task loops to calculate the registration. Examples: `FOV_ROI_table` => loop over the field of views, `well_ROI_table` => process the whole well as one image.",
            "title": "Roi Table",
            "type": "string"
          },
          "zarr_url": {
            "description": "Path or url to the individual OME-Zarr image to be processed. Refers to the zarr_url of the reference cycle. (standard argument for Fractal tasks, managed by Fractal server).",
            "title": "Zarr Url",
            "type": "string"
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "title": "FindRegistrationConsensus",
        "type": "object"
      },
      "docs_info": "## init_group_by_well_for_multiplexing\nFinds images for all acquisitions per well.\n\nReturns the parallelization_list to run `find_registration_consensus`.\n## find_registration_consensus\nApplies pre-calculated registration to ROI tables.\n\nApply pre-calculated registration such that resulting ROIs contain\nthe consensus align region between all cycles.\n\nParallelization level: well\n",
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core",
      "executable_non_parallel": "tasks/init_group_by_well_for_multiplexing.py",
      "executable_parallel": "tasks/find_registration_consensus.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 1000
      },
      "name": "Find Registration Consensus"
    },
    {
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "overwrite_input": {
            "default": true,
            "description": "Whether the old image data should be replaced with the newly registered image data. Currently only implemented for `overwrite_input=True`.",
            "title": "Overwrite Input",
            "type": "boolean"
          },
          "reference_cycle": {
            "default": "0",
            "description": "Which cycle to register against. Defaults to 0, which is the first OME-Zarr image in the well, usually the first cycle that was provided",
            "title": "Reference Cycle",
            "type": "string"
          },
          "registered_roi_table": {
            "description": "Name of the ROI table which has been registered and will be applied to mask and shift the images. Examples: `registered_FOV_ROI_table` => loop over the field of views, `registered_well_ROI_table` => process the whole well as one image.",
            "title": "Registered Roi Table",
            "type": "string"
          },
          "zarr_url": {
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).",
            "title": "Zarr Url",
            "type": "string"
          }
        },
        "required": [
          "zarr_url",
          "registered_roi_table"
        ],
        "title": "ApplyRegistrationToImage",
        "type": "object"
      },
      "docs_info": "## apply_registration_to_image\nApply registration to images by using a registered ROI table\n\nThis task consists of 4 parts:\n\n1. Mask all regions in images that are not available in the\nregistered ROI table and store each cycle aligned to the\nreference_cycle (by looping over ROIs).\n2. Do the same for all label images.\n3. Copy all tables from the non-aligned image to the aligned image\n(currently only works well if the only tables are well & FOV ROI tables\n(registered and original). Not implemented for measurement tables and\nother ROI tables).\n4. Clean up: Delete the old, non-aligned image and rename the new,\naligned image to take over its place.\n\nParallelization level: image\n",
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core",
      "executable_parallel": "tasks/apply_registration_to_image.py",
      "input_types": {
        "registered": false
      },
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "name": "Apply Registration to Image",
      "output_types": {
        "registered": true
      }
    },
    {
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "add_grid_ROI_table": {
            "default": true,
            "description": "Whether to add a `grid_ROI_table` table to each image, with the image split into a rectangular grid of ROIs.",
            "title": "Add Grid Roi Table",
            "type": "boolean"
          },
          "add_image_ROI_table": {
            "default": true,
            "description": "Whether to add a `image_ROI_table` table to each image, with a single ROI covering the whole image.",
            "title": "Add Image Roi Table",
            "type": "boolean"
          },
          "grid_x_shape": {
            "default": 2,
            "description": "X shape of the ROI grid in `grid_ROI_table`.",
            "title": "Grid X Shape",
            "type": "integer"
          },
          "grid_y_shape": {
            "default": 2,
            "description": "Y shape of the ROI grid in `grid_ROI_table`.",
            "title": "Grid Y Shape",
            "type": "integer"
          },
          "overwrite": {
            "default": false,
            "description": "Whether new ROI tables (added when `add_image_ROI_table` and/or `add_grid_ROI_table` are `True`) can overwite existing ones.",
            "title": "Overwrite",
            "type": "boolean"
          },
          "update_omero_metadata": {
            "default": true,
            "description": "Whether to update Omero-channels metadata, to make them Fractal-compatible.",
            "title": "Update Omero Metadata",
            "type": "boolean"
          },
          "zarr_dir": {
            "description": "path of the directory where the new OME-Zarrs will be created. (standard argument for Fractal tasks, managed by Fractal server).",
            "title": "Zarr Dir",
            "type": "string"
          },
          "zarr_name": {
            "description": "The OME-Zarr name, without its parent folder. The parent folder is provided by zarr_dir; e.g. `zarr_name=\"array.zarr\"`, if the OME-Zarr path is in `/zarr_dir/array.zarr`.",
            "title": "Zarr Name",
            "type": "string"
          },
          "zarr_urls": {
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. Not used. (standard argument for Fractal tasks, managed by Fractal server).",
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array"
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir",
          "zarr_name"
        ],
        "title": "ImportOmeZarr",
        "type": "object"
      },
      "docs_info": "## import_ome_zarr\nImport a single OME-Zarr into Fractal.\n\nThe single OME-Zarr can be a full OME-Zarr HCS plate or an individual\nOME-Zarr image. The image needs to be in the zarr_dir as specified by the\ndataset. The current version of this task:\n\n1. Creates the appropriate components-related metadata, needed for\n   processing an existing OME-Zarr through Fractal.\n2. Optionally adds new ROI tables to the existing OME-Zarr.\n",
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core",
      "executable_non_parallel": "tasks/import_ome_zarr.py",
      "name": "Import OME-Zarr"
    },
    {
      "args_schema_parallel": {
        "additionalProperties": false,
        "definitions": {
          "ChannelInputModel": {
            "description": "A channel which is specified by either `wavelength_id` or `label`.",
            "properties": {
              "label": {
                "description": "Name of the channel.",
                "title": "Label",
                "type": "string"
              },
              "wavelength_id": {
                "description": "Unique ID for the channel wavelength, e.g. `A01_C01`.",
                "title": "Wavelength Id",
                "type": "string"
              }
            },
            "title": "ChannelInputModel",
            "type": "object"
          },
          "NapariWorkflowsInput": {
            "description": "A value of the `input_specs` argument in `napari_workflows_wrapper`.",
            "properties": {
              "channel": {
                "$ref": "#/definitions/ChannelInputModel",
                "description": "`ChannelInputModel` object (for image inputs only).",
                "title": "Channel"
              },
              "label_name": {
                "description": "Label name (for label inputs only).",
                "title": "Label Name",
                "type": "string"
              },
              "type": {
                "description": "Input type (either `image` or `label`).",
                "enum": [
                  "image",
                  "label"
                ],
                "title": "Type",
                "type": "string"
              }
            },
            "required": [
              "type"
            ],
            "title": "NapariWorkflowsInput",
            "type": "object"
          },
          "NapariWorkflowsOutput": {
            "description": "A value of the `output_specs` argument in `napari_workflows_wrapper`.",
            "properties": {
              "label_name": {
                "description": "Label name (for label outputs, it is used as the name of the label; for dataframe outputs, it is used to fill the `region[\"path\"]` field).",
                "title": "Label Name",
                "type": "string"
              },
              "table_name": {
                "description": "Table name (for dataframe outputs only).",
                "title": "Table Name",
                "type": "string"
              },
              "type": {
                "description": "Output type (either `label` or `dataframe`).",
                "enum": [
                  "label",
                  "dataframe"
                ],
                "title": "Type",
                "type": "string"
              }
            },
            "required": [
              "type",
              "label_name"
            ],
            "title": "NapariWorkflowsOutput",
            "type": "object"
          }
        },
        "properties": {
          "expected_dimensions": {
            "default": 3,
            "description": "Expected dimensions (either `2` or `3`). Useful when loading 2D images that are stored in a 3D array with shape `(1, size_x, size_y)` [which is the default way Fractal stores 2D images], but you want to make sure the napari workflow gets a 2D array to process. Also useful to set to `2` when loading a 2D OME-Zarr that is saved as `(size_x, size_y)`.",
            "title": "Expected Dimensions",
            "type": "integer"
          },
          "input_ROI_table": {
            "default": "FOV_ROI_table",
            "description": "Name of the ROI table over which the task loops to apply napari workflows. Examples: `FOV_ROI_table` => loop over the field of views; `organoid_ROI_table` => loop over the organoid ROI table (generated by another task); `well_ROI_table` => process the whole well as one image.",
            "title": "Input Roi Table",
            "type": "string"
          },
          "input_specs": {
            "additionalProperties": {
              "$ref": "#/definitions/NapariWorkflowsInput"
            },
            "description": "A dictionary of `NapariWorkflowsInput` values.",
            "title": "Input Specs",
            "type": "object"
          },
          "level": {
            "default": 0,
            "description": "Pyramid level of the image to be used as input for napari-workflows. Choose `0` to process at full resolution. Levels > 0 are currently only supported for workflows that only have intensity images as input and only produce a label images as output.",
            "title": "Level",
            "type": "integer"
          },
          "output_specs": {
            "additionalProperties": {
              "$ref": "#/definitions/NapariWorkflowsOutput"
            },
            "description": "A dictionary of `NapariWorkflowsOutput` values.",
            "title": "Output Specs",
            "type": "object"
          },
          "overwrite": {
            "default": true,
            "description": "If `True`, overwrite the task output.",
            "title": "Overwrite",
            "type": "boolean"
          },
          "relabeling": {
            "default": true,
            "description": "If `True`, apply relabeling so that label values are unique across all ROIs in the well.",
            "title": "Relabeling",
            "type": "boolean"
          },
          "workflow_file": {
            "description": "Absolute path to napari-workflows YAML file",
            "title": "Workflow File",
            "type": "string"
          },
          "zarr_url": {
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server).",
            "title": "Zarr Url",
            "type": "string"
          }
        },
        "required": [
          "zarr_url",
          "workflow_file",
          "input_specs",
          "output_specs"
        ],
        "title": "NapariWorkflowsWrapper",
        "type": "object"
      },
      "docs_info": "## napari_workflows_wrapper\nRun a napari-workflow on the ROIs of a single OME-NGFF image.\n\nThis task takes images and labels and runs a napari-workflow on them that\ncan produce a label and tables as output.\n\nExamples of allowed entries for `input_specs` and `output_specs`:\n\n```\ninput_specs = {\n    \"in_1\": {\"type\": \"image\", \"channel\": {\"wavelength_id\": \"A01_C02\"}},\n    \"in_2\": {\"type\": \"image\", \"channel\": {\"label\": \"DAPI\"}},\n    \"in_3\": {\"type\": \"label\", \"label_name\": \"label_DAPI\"},\n}\n\noutput_specs = {\n    \"out_1\": {\"type\": \"label\", \"label_name\": \"label_DAPI_new\"},\n    \"out_2\": {\"type\": \"dataframe\", \"table_name\": \"measurements\"},\n}\n```\n",
      "docs_link": "https://fractal-analytics-platform.github.io/fractal-tasks-core",
      "executable_parallel": "tasks/napari_workflows_wrapper.py",
      "meta_parallel": {
        "cpus_per_task": 8,
        "mem": 32000
      },
      "name": "Napari workflows wrapper"
    }
  ]
}
